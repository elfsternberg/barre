type NodeId = usize;

/// A language of <T> recognizes a few different things:
///    Empty: the Empty expression, which matches no strings at all
///    Epsilon: the Empty string, which matches... the empty string, of course!
///    Obj, which matches a single object (for example, a character)
///    Cat, which matches concatenations of the language (one character following another)
///    Alt, which matches alternatives between languages (|)
///    Repeat, which matches the language repeated  (*)
///
///    Eventually, I hope to add specializations such as Any (which is a specialization of Cat),
///    (+), which is the Cat of a Char and a Repeat, and from there... who knows?
///
/// Fortunately, languages are small and cheap, in this implementation, consisting at most
/// of a single tuple.

#[derive(Debug, Clone, PartialEq)]
pub enum Language<T> 
    where T: std::clone::Clone + std::cmp::PartialEq + std::fmt::Debug
{
    Empty,
    Epsilon,
    Token(T),
    Alt(NodeId, NodeId),
//    Cat(NodeId, NodeId),
//    Repeat(NodeId),
}

/*
impl<T> Language<T>
    where T: std::clone::Clone + std::cmp::PartialEq + std::fmt::Debug
{
    pub fn todot(&self) {
        match self {
            Language::Empty => println!("[Empty]"),
            Language::Epsilon => println!("[Epsilon]"),
            Language::Token(ref i) => println!("[Token ({:?})]", i),
            Language::Alt(l, r) => println!("[Alternate ({}, {})]", l, r)
        }
    }
}
*/

/// Given an expression, recognize if the string matches the expression.
///
/// Traditionally, regular expressions emerged from *generative*
/// descriptions, that is, the expression engine described a way of
/// *generating* a series of strings, and then the trick was to ask,
/// "Could this string be generated by this generator?"
///
/// We're going straight for a simple recognizer.  It's a shame that
/// "recognizer" is one of those steps in learning about parsing
/// that's never covered in much depth.
///
/// For our purpose, a recognizer is a vector of language atoms.
/// Language atoms that refer to other language atoms use the index of
/// those atoms to look them up.  Once a recognizer has been built,
/// it's starting point is the LAST item pushed into the arena.

#[derive(Debug)]
pub struct Recognizer<T>
    where T: std::clone::Clone + std::cmp::PartialEq + std::fmt::Debug
{
    language: Vec<Language<T>>,
    pos: usize,
}

/// The implementation of this is a vector of Language items.

impl<T> Recognizer<T>
    where T: std::clone::Clone + std::cmp::PartialEq + std::fmt::Debug
{

    /// By default, a Recognizer recognizes only the Empty Language,
    /// i.e.  *no* strings can be recognized.
    pub fn new() -> Recognizer<T> {
        // Currently, this recognizer recognizes no strings of tokens
        let mut lang = Recognizer::<T> {
            language: Vec::with_capacity(20),
            pos: 0,
        };
        lang.language.push(Language::Empty);
        lang.language.push(Language::Epsilon);
        assert!(lang.language[0] == Language::Empty);
        lang
    }

    /// Push a token into the recognizer, returning its index.
    pub fn add_tok(&mut self, t: T) -> usize{
        self.language.push(Language::Token(t));
        self.pos = self.language.len() - 1;
        self.pos
    }

    /// Push an alternator into the recognizer, returning its index.
    pub fn add_alt(&mut self, l: usize, r: usize) -> usize {
        self.language.push(Language::Alt(l, r));
        self.pos = self.language.len() - 1;
        self.pos
    }

    /// This is the function that determines if it's possible for the
    /// current Language to be nullable (that is, it can return the
    /// empty string).  If it can, then matching can continue, or the
    /// result is true; otherwise false.
    pub fn nullable(&self, i: usize) -> bool {
        match self.language[i] {
            Language::Empty => false,
            Language::Epsilon => true,
            Language::Token(_) => false,
            Language::Alt(l, r) => self.nullable(l) || self.nullable(r),
//            Repeat(_) => true,
//            Cat(l, r) => nullable(l) && nullable(r),
        }
    }

    /// Given a step in the recognizer, finds the derivative of the
    /// current step after any symbols have been considered.
    pub fn derive(&mut self, c: &T, p: usize) -> usize {
        match self.language[p].clone() {
            Language::Empty => 0,
            Language::Epsilon => 1,
            Language::Token(ref d) => {
                if *d == *c { 1 } else { 0 }
            },
            Language::Alt(l, r) => {
                let dl = self.derive(c, l);
                let dr = self.derive(c, r);
                self.add_alt(dl, dr)
            },
/*
            Cat(l, r) => {
                let left_derivative = Cat(Box::new(derive(c, l)), *r);
                if nullable(&left_derivative) {
                    Alt(left_derivative, derive(c, r))
                } else {
                    left_derivative
                }
            }
            Repeat(n) => Cat(derive(c, n), n),
             */
        }
    }

    pub fn inner_recognize<I>(&mut self, items: &mut I) -> bool
        where I: Iterator<Item = T>
    {
        let p = self.pos;
        {
            match items.next() {
                None => self.nullable(p),
                Some(c) => {
                    let np = self.derive(&c, p);
                    let nl = self.language[np].clone();
                    match nl {
                        Language::Empty => false,
                        Language::Epsilon => true,
                        _ => {
                            self.pos = np;
                            self.inner_recognize(items)
                        }
                    }
                }
            }
        }
    }

    pub fn recognize<I>(&mut self, items: &mut I) -> bool
        where I: Iterator<Item = T>
    {
        let p = self.pos;
        let r = self.inner_recognize(items);
        self.pos = p;
        r
    }
}

#[cfg(test)]
mod tests {
    use Recognizer;

    #[test]
    fn it_works() {
        let mut pattern = Recognizer::<char>::new();
        assert!(pattern.nullable(0) == false);
        assert!(pattern.nullable(1) == true);

        pattern.add_tok('A');
        assert!(pattern.nullable(2) == false);
        assert!(pattern.recognize(&mut String::from("A").chars()) == true);
        assert!(pattern.recognize(&mut String::from("B").chars()) == false);
    }

    #[test]
    fn alt_matches() {
        let mut pattern = Recognizer::<char>::new();
        let l = pattern.add_tok('A');
        let r = pattern.add_tok('B');
        let altpattern = pattern.add_alt(l, r);
        assert!(pattern.nullable(altpattern) == false);

        assert!(pattern.recognize(&mut String::from("A").chars()) == true);
        assert!(pattern.recognize(&mut String::from("B").chars()) == true);
        assert!(pattern.recognize(&mut String::from("C").chars()) == false);
    }
        
/*        
        let floater = cat!(
            alt!(Eps, Char("+"), Char("-")),
            Rep(digit),
            Char("."),
            digit,
            Rep(digit)
        );
        assert(rematch("-2.0", floater));
        assert(rematch("+12.12", floater));
        assert(rematch("1.0", floater));
        assert(rematch("1", floater) == false);
        assert(rematch("", floater) == false);
*/
}
