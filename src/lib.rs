use std::fmt;

type NodeId = usize;

/// A language of <T> recognizes a few different things:
///    Empty: the Empty expression, which matches no strings at all
///    Epsilon: the Empty string, which matches... the empty string, of course!
///    Obj, which matches a single object (for example, a character)
///    Cat, which matches concatenations of the language (one character following another)
///    Alt, which matches alternatives between languages (|)
///    Repeat, which matches the language repeated  (*)
///
///    Eventually, I hope to add specializations such as Any (which is a specialization of Cat),
///    (+), which is the Cat of a Char and a Repeat, and from there... who knows?
///
/// Fortunately, languages are small and cheap, in this implementation, consisting at most
/// of a single tuple.

#[derive(Debug, Clone, PartialEq)]
pub enum Language<T>
where
    T: std::clone::Clone + std::cmp::PartialEq + std::fmt::Debug + std::fmt::Display,
{
    Empty,
    Epsilon,
    Token(T),
    Alt(NodeId, NodeId),
    Cat(NodeId, NodeId),
    Repeat(NodeId),
}


/// Given an expression, recognize if the string matches the expression.
///
/// Traditionally, regular expressions emerged from *generative*
/// descriptions, that is, the expression engine described a way of
/// *generating* a series of strings, and then the trick was to ask,
/// "Could this string be generated by this generator?"
///
/// We're going straight for a simple recognizer.  It's a shame that
/// "recognizer" is one of those steps in learning about parsing
/// that's never covered in much depth.
///
/// For our purpose, a recognizer is a vector of language atoms.
/// Language atoms that refer to other language atoms use the index of
/// those atoms to look them up.  Once a recognizer has been built,
/// it's starting point is the LAST item pushed into the arena.

#[derive(Debug, Clone)]
pub struct Recognizer<T>
where
    T: std::clone::Clone + std::cmp::PartialEq + std::fmt::Debug + std::fmt::Display
{
    language: Vec<Language<T>>,
    pos: usize,
}

/// The implementation of this is a vector of Language items.

impl<T> Recognizer<T>
where
    T: std::clone::Clone + std::cmp::PartialEq + std::fmt::Debug + std::fmt::Display,
{
    /// By default, a Recognizer recognizes only the Empty Language,
    /// i.e.  *no* strings can be recognized.
    pub fn new() -> Recognizer<T> {
        // Currently, this recognizer recognizes no strings of tokens
        let mut lang = Recognizer::<T> {
            language: Vec::with_capacity(20),
            pos: 0,
        };
        lang.language.push(Language::Empty);
        lang.language.push(Language::Epsilon);
        lang
    }

    
    /// Push a token into the recognizer, returning its index.
    pub fn add_tok(&mut self, t: T) -> usize {
        self.language.push(Language::Token(t));
        self.language.len() - 1
    }

    /// Push an alternator into the recognizer, returning its index.
    pub fn add_alt(&mut self, l: usize, r: usize) -> usize {
        self.language.push(Language::Alt(l, r));
        self.language.len() - 1
    }

    pub fn add_cat(&mut self, l: usize, r: usize) -> usize {
        self.language.push(Language::Cat(l, r));
        self.language.len() - 1
    }

    pub fn add_rep(&mut self, n: usize) -> usize {
        self.language.push(Language::Repeat(n));
        self.language.len() - 1
    }

    fn reinit(&mut self) {
        self.pos = self.language.len() - 1
    }
    
    /// This is the function that determines if it's possible for the
    /// current Language to be nullable (that is, it can return the
    /// empty string).  If it can, then matching can continue, or the
    /// result is true; otherwise false.
    pub fn nullable(&self, i: usize) -> bool {
        match self.language[i] {
            Language::Empty => false,
            Language::Epsilon => true,
            Language::Token(_) => false,
            Language::Alt(l, r) => self.nullable(l) || self.nullable(r),
            Language::Cat(l, r) => self.nullable(l) && self.nullable(r),
            Language::Repeat(_) => true,
        }
    }

    /// Given a step in the recognizer, finds the derivative of the
    /// current step after any symbols have been considered.
    pub fn derive(&mut self, c: &T, p: usize) -> usize {
        match self.language[p].clone() {
            Language::Empty => 0,
            Language::Epsilon => 1,
            Language::Token(ref d) => {
                if *d == *c {
                    1
                } else {
                    0
                }
            }
            Language::Alt(l, r) => {
                let dl = self.derive(c, l);
                let dr = self.derive(c, r);
                self.add_alt(dl, dr)
            }
            Language::Cat(l, r) => {
                let derived_left = self.derive(c, l);
                let left_derivative = self.add_cat(derived_left, r);
                if self.nullable(derived_left) {
                    let right_derivative = self.derive(c, r);
                    self.add_alt(left_derivative, right_derivative)
                } else {
                    left_derivative
                }
            }
            Language::Repeat(n) => {
                let derived = self.derive(c, n);
                self.add_cat(derived, p)
            }
        }
    }

    pub fn inner_recognize<I>(&mut self, items: &mut I) -> bool
    where
        I: Iterator<Item = T>,
    {
        let p = self.pos;
        {
            match items.next() {
                None => self.nullable(p),
                Some(c) => {
                    let np = self.derive(&c, p);
                    let nl = self.language[np].clone();
                    match nl {
                        Language::Empty => false,
                        Language::Epsilon => true,
                        // Essentially, for all other possibilities, we
                        // just need to recurse across our nodes until
                        // we hit Empty or Epsilon, and then we're
                        // done.
                        _ => {
                            self.pos = np;
                            self.inner_recognize(items)
                        }
                    }
                }
            }
        }
    }

    pub fn recognize<I>(&mut self, items: &mut I) -> bool
    where
        I: Iterator<Item = T>,
    {
        let mut pattern = self.clone();
        pattern.reinit();
        pattern.inner_recognize(items)
    }
}

impl<T> fmt::Display for Recognizer<T> 
    where T: std::clone::Clone + std::cmp::PartialEq + std::fmt::Debug + std::fmt::Display
{
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fn fmt_helper<T>(f: &mut fmt::Formatter, language: &Vec<Language<T>>, p: usize) -> fmt::Result
            where T: std::clone::Clone + std::cmp::PartialEq + std::fmt::Debug + std::fmt::Display
        {
            match language[p] {
                Language::Empty => write!(f, "⊘")?,
                Language::Epsilon => write!(f, "ε")?,
                Language::Token(ref i) => write!(f, "{}", i)?,
                Language::Alt(l, r) => {
                    write!(f, "(")?;
                    fmt_helper(f, language, l)?;
                    write!(f, "|")?;
                    let mut c = r;
                    loop {
                        let p = match language[c] {
                            Language::Alt(l, r) => {
                                fmt_helper(f, language, l)?;
                                write!(f, "|");
                                r
                            },
                            _ => {
                                fmt_helper(f, language, r)?;
                                write!(f, ")");
                                break;
                            }
                        };
                        c = p;
                    }
                    write!(f, "")?;
                }
                Language::Cat(l, r) => {
                    fmt_helper(f, language, l)?;
                    fmt_helper(f, language, r)?;
                }
                Language::Repeat(n) => {
                    write!(f, "(")?;
                    fmt_helper(f, language, n)?;
                    write!(f, ")*")?;
                }
            }
            write!(f, "")
        }

        let start = self.language.len() - 1;
        fmt_helper(f, &self.language, start)
    }            
}


#[cfg(test)]
mod tests {
    use Recognizer;
    /*
    #[test]
    fn it_works() {
        let mut pattern = Recognizer::<char>::new();
        assert!(pattern.nullable(0) == false);
        assert!(pattern.nullable(1) == true);

        pattern.add_tok('A');
        assert!(pattern.nullable(2) == false);
        assert!(pattern.recognize(&mut String::from("A").chars()) == true);
        assert!(pattern.recognize(&mut String::from("B").chars()) == false);
        assert!(pattern.recognize(&mut String::from("").chars()) == false);
    }

    #[test]
    fn alt_matches() {
        let mut pattern = Recognizer::<char>::new();
        let l = pattern.add_tok('A');
        let r = pattern.add_tok('B');
        let altpattern = pattern.add_alt(l, r);
        assert!(pattern.nullable(altpattern) == false);

        assert!(pattern.recognize(&mut String::from("A").chars()) == true);
        assert!(pattern.recognize(&mut String::from("B").chars()) == true);
        assert!(pattern.recognize(&mut String::from("C").chars()) == false);
    }
    #[test]
    fn cat_matches() {
        let mut pattern = Recognizer::<char>::new();
        let a = pattern.add_tok('A');
        let b = pattern.add_tok('B');
        let c = pattern.add_tok('C');
        let d = pattern.add_tok('D');
        let e = pattern.add_cat(c, d);
        let f = pattern.add_cat(b, e);
        let _ = pattern.add_cat(a, f);
        assert!(pattern.recognize(&mut String::from("ABCD").chars()) == true);
        assert!(pattern.recognize(&mut String::from("ACBD").chars()) == false);
    }
*/

    #[test]
    fn can_display() {
        let mut pattern = Recognizer::<char>::new();
        let a = pattern.add_tok('A');
        let b = pattern.add_tok('B');
        let f = pattern.add_cat(a, b);
        let g = pattern.add_rep(f);
        let h = pattern.add_tok('C');
        let _ = pattern.add_cat(g, h);
        assert!(format!("{}", pattern) == "(AB)*C");
    }
    
    #[test]
    fn repeat_matches() {
        let mut pattern = Recognizer::<char>::new();
        let a = pattern.add_tok('A');
        let b = pattern.add_tok('B');
        let f = pattern.add_cat(a, b);
        let g = pattern.add_rep(f);
        let h = pattern.add_tok('C');
        let _ = pattern.add_cat(g, h);

//        assert!(pattern.recognize(&mut String::from("ABC").chars()) == true);
//        assert!(pattern.recognize(&mut String::from("ABABC").chars()) == true);
//        assert!(pattern.recognize(&mut String::from("ABABABABABC").chars()) == true);
//        assert!(pattern.recognize(&mut String::from("ABABABABAAC").chars()) == false);
        println!("{}", pattern);
        assert!(pattern.recognize(&mut String::from("C").chars()) == true);
     }        
            

    /*        
        let floater = cat!(
            alt!(Eps, Char("+"), Char("-")),
            Rep(digit),
            Char("."),
            digit,
            Rep(digit)
        );
        assert(rematch("-2.0", floater));
        assert(rematch("+12.12", floater));
        assert(rematch("1.0", floater));
        assert(rematch("1", floater) == false);
        assert(rematch("", floater) == false);
*/
}
